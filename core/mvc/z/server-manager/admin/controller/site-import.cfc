<cfcomponent>
<cfoutput>
<cffunction name="index" localmode="modern" access="remote" roles="serveradministrator">
	<cfscript>
	var db=request.zos.queryObject;
	var selectStruct=0;
	application.zcore.functions.zSetPageHelpId("8.1.2");
	application.zcore.functions.zStatusHandler(request.zsid);
	</cfscript>
	
	<form action="/z/server-manager/admin/site-import/process" method="post" enctype="multipart/form-data">
		<table style="width:100%; border-spacing:0px;" class="table-white">
			<tr>
				<td colspan="2" style="padding:10px; padding-bottom:0px;"><span class="large"><h2>Site Import</h2></span>
				</td>
			</tr>
			<tr>
				<td colspan="2" style="padding-left:10px;">
				<p>Choosing an existing site or click "Add Site" to create one.  The site id columns will be automatically updated as needed.</p>
				<p><strong>WARNING: If the import process fails, there may be permanent data loss.</strong>  Make sure you have made backups before updating an existing site.</p></td>
			</tr>
			<tr>
				<td class="table-list" style="vertical-align:top; width:140px;">Site Tar File:</td>
				<td class="table-white"><input type="file" name="tarFile" /> (Required | This file must be generated by a Site Backup task in the Jetendo Server Manager).
				</td>
			</tr>
			<tr>
				<td class="table-list" style="vertical-align:top; width:140px;">Site Uploads Tar File:</td>
				<td class="table-white"><input type="file" name="theUploadFile" /> (Optional | A simple 7-zip file contain the files in /zupload directory.  If not specified, an existing zupload folder will be retained.)
				</td>
			</tr>
			<tr>
				<td class="table-list" style="vertical-align:top; width:140px;">Select Parent Site: </td>
				<td class="table-white">
				<cfscript>
				db.sql="SELECT site_id, replace(site_short_domain, '.#request.zos.testDomain#', '') site_short_domain FROM #db.table("site", request.zos.zcoreDatasource)# site 
				WHERE site_id <> #db.param(-1)#
				ORDER BY site_short_domain ASC";
				local.qSites=db.execute("qSites");
				selectStruct = StructNew();
				selectStruct.name = "sidParent";
				selectStruct.query = qSites;
				selectStruct.queryLabelField = "site_short_domain";
				selectStruct.queryValueField = "site_id";
				application.zcore.functions.zInputSelectBox(selectStruct);
				</cfscript> (Leave unselected if this site is not connected to another site).
				</td>
			</tr>
			<tr>
				<td class="table-list" style="vertical-align:top; width:140px;">Import Type:</td>
				<td class="table-white">
				<input type="radio" name="importType" value="update" /> Update Existing Site 
				<input type="radio" name="importType" value="insert" /> Add New Site
				</td>
			</tr>
			<tr>
				<td class="table-list" style="vertical-align:top; width:140px;">Select Site To Overwrite:</td>
				<td class="table-white">
				<cfscript>
				selectStruct = StructNew();
				selectStruct.name = "sid";
				selectStruct.query = qSites;
				selectStruct.queryLabelField = "site_short_domain";
				selectStruct.queryValueField = "site_id";
				application.zcore.functions.zInputSelectBox(selectStruct);
				</cfscript> (Only applies when you select "Update Existing Site" above)
				</td>
			</tr>
			<cfif not request.zos.istestserver>
			<tr>
				<td class="table-list" style="vertical-align:top; width:140px;">Linux Username:</td>
				<td class="table-white"><input type="text" name="linuxUser" value="" /> (Optional, only needed when there is a conflict with existing user)
				</td>
			</tr>
			</cfif>
			<tr>
				<td class="table-list" style="vertical-align:top; width:140px;">Ignore Database Structure Errors?</td>
				<td class="table-white"><input type="checkbox" name="ignoreDBErrors" value="1" />
				</td>
			</tr>
			<!--- <tr>
				<td class="table-list" style="vertical-align:top; width:140px;">Backup Site Before Import?</td>
				<td class="table-white"><input type="checkbox" name="backupSite" value="1" />
				</td>
			</tr> --->
			<tr>
				<td class="table-list" style="vertical-align:top; width:140px;">&nbsp;</td>
				<td class="table-white">
				<input type="submit" name="submit1" value="Import Site" />
				</td>
			</tr>
		</table>
		
	</form>
</cffunction>
	
<cffunction name="process" localmode="modern" access="remote" roles="serveradministrator">
	<cfscript>
	var db=request.zos.queryObject;
	var dbNoVerify=request.zos.noVerifyQueryObject;
	var i=0;
	var n=0;
	var cfcatch=0;
	var g=0;
	var row=0;
	var debug=false;
	writeoutput('disabled to to changes not being done.');
	setting requesttimeout="3600";
	form.sid=application.zcore.functions.zso(form, 'sid');
	form.importType=application.zcore.functions.zso(form, 'importType');
	form.sidParent=application.zcore.functions.zso(form, 'sidParent');
	form.ignoreDBErrors=application.zcore.functions.zso(form,'ignoreDBErrors', false, false);
	if(form.importType EQ ""){
		application.zcore.status.setStatus(request.zsid, "Import type is required.", form, true);
		application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
	}
	
	application.zcore.functions.zCreateDirectory(request.zos.backupDirectory&"import/");
	local.curDate=dateformat(now(), "yyyymmdd")&"-"&timeformat(now(),"HHmmss");
	local.curImportPath=request.zos.backupDirectory&"import/"&local.curDate&"/";
	local.curMYSQLImportPath=request.zos.mysqlBackupDirectory&"import/"&local.curDate&"/";
	
	// create new directories
	application.zcore.functions.zCreateDirectory(local.curImportPath);
	application.zcore.functions.zCreateDirectory(local.curImportPath&"upload/");
	application.zcore.functions.zCreateDirectory(local.curImportPath&"temp/");
	
	local.filePath=application.zcore.functions.zUploadFile("tarFile", "#local.curImportPath#upload/");
	if(local.filePath EQ false){
		application.zcore.status.setStatus(request.zsid, "The site backup file failed to upload. Please try again", form, true);
		application.zcore.functions.zdeletedirectory(local.curImportPath);
application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
	}
	local.filePath="#local.curImportPath#upload/"&local.filePath;
	
	if(right(local.filePath, 7) NEQ ".tar.gz"){
		application.zcore.status.setStatus(request.zsid, "A site backup file must end with "".tar.gz"".  Only files generated by the site backup task are compatible with site import.  Don't try to package your own backup file.", form, true);
		application.zcore.functions.zdeletedirectory(local.curImportPath);
		application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
	}
	if(structkeyexists(form, 'theUploadFile') and form.theUploadFile NEQ ""){
		local.fileUploadPath=application.zcore.functions.zUploadFile("theUploadFile", "#local.curImportPath#upload/");
		if(local.fileUploadPath EQ false){
			application.zcore.status.setStatus(request.zsid, "The site uploads backup file failed to upload. Please try again", form, true);
			application.zcore.functions.zdeletedirectory(local.curImportPath);
	application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
		}
		local.fileUploadPath="#local.curImportPath#upload/"&local.fileUploadPath;
		if(right(local.fileUploadPath, 7) NEQ ".tar.gz"){
			application.zcore.status.setStatus(request.zsid, "A site upload backup file must end with "".tar.gz"".  Only files generated by the site backup task are compatible with site import.  Don't try to package your own backup file.", form, true);
			application.zcore.functions.zdeletedirectory(local.curImportPath);
			application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
		}
	}
	// isTarred=application.zcore.functions.zTarZipFilePath("myTarball.tar.gz", "/opt/jetendo/sites/", "/opt/jetendo/sites/basicdemo_farbeyondcode_com/", 20);
	//('/bin/tar', 'xvzf  "#local.filePath#" --exclude=files  -C "#local.curImportPath#temp/" ', 3600);
	
	local.globals=deserializeJson(application.zcore.functions.zreadfile(local.curImportPath&"temp/globals.json"));
	local.installPath=application.zcore.functions.zGetDomainInstallPath(local.globals.site_short_domain);
	// update the globals
	local.ts=structnew();
	local.ts.struct=local.globals;
	if(request.zos.isTestServer){
		if(local.ts.struct.site_domain DOES NOT CONTAIN "."&request.zos.testDomain){
			local.ts.struct.site_domain=replace(local.ts.struct.site_domain&"."&request.zos.testDomain, "https://", "http://");
		}
		if(local.ts.struct.site_securedomain NEQ "" and local.ts.struct.site_securedomain DOES NOT CONTAIN "."&request.zos.testDomain){
			local.ts.struct.site_securedomain=replace(local.ts.struct.site_securedomain&"."&request.zos.testDomain, "https://", "http://");
		}
	}else{
		if(local.ts.struct.site_domain CONTAINS "."&request.zos.testDomain){
			local.ts.struct.site_domain=replace(local.ts.struct.site_domain, "."&request.zos.testDomain, "");
		}
		if(local.ts.struct.site_securedomain NEQ "" and local.ts.struct.site_securedomain CONTAINS "."&request.zos.testDomain){
			local.ts.struct.site_securedomain=replace(local.ts.struct.site_securedomain, "."&request.zos.testDomain, "");
		}
	}
	if(form.sidParent NEQ ""){
		local.ts.struct.site_parent_id=form.sidParent;
	}else{
		// force parent site to be removed for enhanced security
		local.ts.struct.site_parent_id=0;
	}
	if(application.zcore.functions.zso(form, 'linuxUser', false,'') NEQ ""){
		local.ts.struct.site_username=form.linuxUser;
	}
	local.ts.table="site";
	local.ts.datasource=request.zos.zcoredatasource;
	if(form.importType EQ "update"){
		if(form.sid NEQ ""){
			local.ts.struct.site_id=form.sid;
		}
		db.sql="select * from #db.table("site", request.zos.zcoreDatasource)#
		where site_id =#db.param(local.ts.struct.site_id)# ";
		local.qCheck=db.execute("qCheck");
		if(local.qCheck.recordcount EQ 0){
			application.zcore.status.setStatus(request.zsid, "Domain, #local.globals.site_short_domain#, doesn't exist in site table yet.  Please import with the ""Add Site"" option or select an existing site from the drop down menu.", form, true);
			application.zcore.functions.zdeletedirectory(local.curImportPath);
			application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
		}
		if(not directoryexists(local.installPath)){
			application.zcore.status.setStatus(request.zsid, "Domain doesn't exist on the file system, but it is in the site table.  Please run the ""Verify Sites"" task from the Jetendo CMS Server Manager to repair the installation.", form, true);
			application.zcore.functions.zdeletedirectory(local.curImportPath);
			application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
		}
	}else if(form.importType EQ "insert"){
		// verify domain doesn't exist in site table or on filesystem
		db.sql="select * from #db.table("site", request.zos.zcoreDatasource)#
		where site_short_domain = #db.param(local.globals.site_short_domain)# ";
		local.qCheck=db.execute("qCheck");
		if(local.qCheck.recordcount NEQ 0){
			application.zcore.status.setStatus(request.zsid, "Domain already exists in site table.  You must delete the existing domain and files before importing.", form, true);
			application.zcore.functions.zdeletedirectory(local.curImportPath);
			application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
		}
		if(not request.zos.istestserver){
			if(local.globals.site_username NEQ ""){
				// linux user must be unique
				db.sql="select * from #db.table("site", request.zos.zcoreDatasource)#
				where site_username = #db.param(local.globals.site_username)# ";
				local.qCheck=db.execute("qCheck");
				if(local.qCheck.recordcount NEQ 0){
					application.zcore.status.setStatus(request.zsid, "Linux user, #local.globals.site_username#, already exists for domain, #local.qCheck.site_short_domain#.  You must specify a different linux user before importing again.", form, true);
					application.zcore.functions.zdeletedirectory(local.curImportPath);
					application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
				}
			}
		}
		
		if(directoryexists(application.zcore.functions.zGetDomainInstallPath(local.globals.site_short_domain))){
			application.zcore.status.setStatus(request.zsid, "Domain already exists on file system, but not in the site table.  You must delete the existing files before importing.", form, true);
			application.zcore.functions.zdeletedirectory(local.curImportPath);
			application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
		}
		
	}else{
		application.zcore.functions.z404("Invalid request");
	}
	
	// process database restore
	local.restoreData=application.zcore.functions.zreadfile(local.curImportPath&"temp/restore-site-database.sql");
	local.arrRestore=listToArray(replace(local.restoreData, "/ZIMPORTPATH/", local.curMYSQLImportPath&"temp/", "ALL"), chr(10));
	
	// verify column list is compatible with current database structure before deleting
	directory action="list" directory="#local.curImportPath#temp/database-schema/" name="local.qDir" recurse="yes";
	local.arrError=[];
	
	local.skipDBStruct={};
	local.fixDBStruct={};
	for(row in local.qDir){
		if(right(row.name, 5) EQ ".json"){
			local.dsStruct=deserializeJson(application.zcore.functions.zreadfile(row.directory&"/"&row.name));
			for(n in local.dsStruct.fieldStruct){
				local.arrTable=listtoarray(replace(n, "`","", "all"), ".");
				if(form.ignoreDBErrors){
					// determine which columns be removed from the query and insert them into a struct
					dbNoVerify.sql="show fields from #dbNoVerify.table(local.arrTable[2], local.arrTable[1])#";
					try{
						local.qFields=dbNoVerify.execute("qFields");
					}catch(Any local.e){
						local.skipDBStruct[n]=true;
						continue;
					}
					local.fixDBStruct[n]={};
					for(local.row2 in local.qFields){
						local.found=false;
						for(g in local.dsStruct.fieldStruct[n]){
							if(local.row2.field EQ g){
								local.found=true;
							}
						}
						if(not local.found){
							local.fixDBStruct[n][local.row2.field]="@dummy";
						}
					}
					// loop the new struct when running the load data infile statements.  Will have to match the `db`.`table` first, then replace `#field#` with @dummy
				}else{
					local.columnList=structkeylist(local.dsStruct.fieldStruct[n], ", ");
					db.sql="select #local.columnList# from #db.table(local.arrTable[2], local.arrTable[1])# ";
					if(structkeyexists(local.dsStruct.fieldStruct[n], "site_id")){
						db.sql&=" where site_id = #db.param(-1)#";
					}
					db.sql&=" LIMIT #db.param(0)#, #db.param(1)#";
					try{
						db.execute("qCheck");
					}catch(Any local.e){
						arrayAppend(local.arrError, "Database structure exception when verifying #n#: "&local.e.message);
					}
				}
			}
		}
	}
	if(arraylen(local.arrError)){
		application.zcore.status.setStatus(request.zsid, arrayToList(local.arrError, "<br />")&"<br /><br />There are a few ways to correct these errors and re-import this site:<br />A) Create the missing column(s) or table(s) in the database.<br />B) Import again with ""ignore database structure errors"" and the missing column data will not be imported.<br />C) Manually update the restore-site-database.sql file in the tar file, re-tar and re-import the file.", form, true);
		application.zcore.functions.zdeletedirectory(local.curImportPath);
		application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
	}
	local.dsStruct={};
	for(i=1;i LTE arraylen(application.zcore.arrGlobalDatasources);i++){
		local.dsStruct[application.zcore.arrGlobalDatasources[i]]=[];
	}
	local.dsStruct[local.globals.site_datasource]=[];
	for(i=1;i LTE arrayLen(local.arrRestore);i++){
		local.skipTable=false;
		for(f in local.skipDBStruct){
			n="`"&replace(replace(f, "`","", "all"), ".", "`.`")&"`";
			if(local.arrRestore[i] CONTAINS n){
				local.skipTable=true;
				break;
			}
		}
		if(local.skipTable){
			continue;
		}
		for(f in local.fixDBStruct){
			n="`"&replace(replace(f, "`","", "all"), ".", "`.`")&"`";
			if(local.arrRestore[i] CONTAINS n){
				for(g IN local.fixDBStruct[f]){
					local.arrRestore[i]=replace(local.arrRestore[i], g, "@dummy");
				}
				break;
			}
		}
		local.curDatasource="";
		for(n in local.dsStruct){
			if(local.arrRestore[i] CONTAINS "`"&n&"`."){
				local.curDatasource=n;
				break;
			}
		}
		if(local.curDatasource EQ ""){
			application.zcore.status.setStatus(request.zsid, "Datasource in query didn't match a datasource on this installation.  You must create a matching datasource name or manually update the restore-site-database.sql file in the tar file and re-tar and re-import the file. - SQL: #local.arrRestore[i]#", form, true);
			application.zcore.functions.zdeletedirectory(local.curImportPath);
			application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
		}
		arrayAppend(local.dsStruct[local.curDatasource], local.arrRestore[i]);
	}
	// all validation is done, do the actual changes now
	// replace the existing site files 
	if(directoryexists(removeChars(local.installPath, len(local.installPath), 1)&"-temp/")){
		application.zcore.functions.zDeleteDirectory(removeChars(local.installPath, len(local.installPath), 1)&"-temp/");
	}
	if(directoryexists(removeChars(local.installPath, len(local.installPath), 1)&"-temp/")){
		application.zcore.status.setStatus(request.zsid, "Failed to delete directory: "&removeChars(local.installPath, len(local.installPath), 1)&"-temp/.  Import was cancelled before the database or filesystem changed.  You may need to restart the web server or Railo to remove the lock on the directory.", form, true);
		application.zcore.functions.zdeletedirectory(local.curImportPath);
		application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
	}
	if(directoryexists(local.installPath)){
		if(debug) writeoutput("Move "&local.installPath&" to "&removeChars(local.installPath, len(local.installPath), 1)&"-temp/<br />");
		application.zcore.functions.zRenameDirectory(local.installPath, removeChars(local.installPath, len(local.installPath), 1)&"-temp/");
	}
	if(directoryexists(local.installPath)){
		application.zcore.status.setStatus(request.zsid, "Failed to rename directory: "&local.installPath&" to "&removeChars(local.installPath, len(local.installPath), 1)&"-temp/.  Import was cancelled before the database or filesystem changed.  You may need to restart the web server or Railo to remove the lock on the directory.", form, true);
		application.zcore.functions.zdeletedirectory(local.curImportPath);
		application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
	}
	
	application.zcore.functions.zcreatedirectory(local.installPath);
	// isTarred=application.zcore.functions.zTarZipFilePath("myTarball.tar.gz", "/opt/jetendo/sites/", "/opt/jetendo/sites/basicdemo_farbeyondcode_com/", 20);
	//('/bin/bash', " -c 'cd #local.installPath#; /bin/tar xvfz #local.filePath# -C #local.installPath# files --transform=""s/^files\///"" --transform=""s/^files$//"" ' ", 3600);
	local.retainZUpload=true;
	if(structkeyexists(local, 'fileUploadPath')){
		local.retainZUpload=false;
		// isTarred=application.zcore.functions.zTarZipFilePath("myTarball.tar.gz", "/opt/jetendo/sites/", "/opt/jetendo/sites/basicdemo_farbeyondcode_com/", 20);
		//('/bin/bash', " -c 'cd #local.installPath#zupload/; /bin/tar xvfz #local.fileUploadPath#' ", 3600);
	}
	if(local.retainZUpload){
		if(debug) writeoutput("Move "&removeChars(local.installPath, len(local.installPath), 1)&"-temp/zupload/"&" to "&local.installPath&"zupload/"&"<br />");
		application.zcore.functions.zRenameDirectory(removeChars(local.installPath, len(local.installPath), 1)&"-temp/zupload/", local.installPath&"zupload/");
	}
	if(form.importType EQ "update"){
		application.zcore.functions.zUpdate(local.ts);
		form.sid=local.globals.site_id;
	}else{
		form.sid=application.zcore.functions.zInsert(local.ts);
	}
	directory action="list" directory="#local.curImportPath#temp/database/" name="local.qDir" recurse="yes";
	for(row in local.qDir){
		if(row.directory NEQ "#local.curImportPath#temp/database" and row.name NEQ "." and row.name NEQ ".."){
			local.database=replace(replace(row.directory,"\","/","all"), "#local.curImportPath#temp/database/", "");
			local.curTable=left(row.name, len(row.name)-4);
			db.sql="delete from #db.table(local.curTable, local.database)# 
			where site_id = #db.param(local.globals.site_id)# ";
			if(debug) writeoutput(db.sql&" | site_id is #local.globals.site_id#<br />");
			db.execute("qDelete");
		}
	}
	for(n in local.dsStruct){
		// manually set datasource because the set variable queries don't use tables
		local.c=application.zcore.db.getConfig();
		local.c.autoReset=false;
		local.c.datasource=n;
		local.c.verifyQueriesEnabled=false;
		dbNoVerify=application.zcore.db.newQuery(local.c);
		dbNoVerify.sql="set @zDisableTriggers=1";
		dbNoVerify.execute("qDisableTrigger");
		for(i=1;i LTE arrayLen(local.dsStruct[n]);i++){
			dbNoVerify.sql=local.dsStruct[n][i];
			if(form.importType EQ "insert" and dbNoVerify.sql CONTAINS "`site_id`"){
				dbNoVerify.sql=replace(dbNoVerify.sql, ";", "")&" SET `site_id` = '"&form.sid&"'";
			}
			if(debug) writeoutput(dbNoVerify.sql&"<br />");
			dbNoVerify.execute("qLoad");
		}
		dbNoVerify.sql="set @zDisableTriggers=NULL";
		dbNoVerify.execute("qEnableTrigger");
	}
	
	// force system to self-heal
	db.sql="UPDATE #db.table("site", request.zos.zcoreDatasource)# 
	SET site_system_user_created=0, 
	site_system_user_modified=1 
	WHERE site_id=#db.param(local.globals.site_id)# ";
	db.execute("qUpdate");
	application.zcore.functions.zdeletedirectory(local.curImportPath);
	
	application.zcore.functions.zDeleteDirectory(removeChars(local.installPath, len(local.installPath), 1)&"-temp/");
	
	application.zcore.functions.zOS_cacheSitePaths();
	application.zcore.functions.zOS_cacheSiteAndUserGroups(local.globals.site_id);
	
	
	try{
		// might need to do this always - don't know yet
		application.zcore.app.appUpdateCache(local.globals.site_id);
	}catch(Any local.e){
		if(debug){
			writeoutput('done, but cache hasn''t updated yet.<a href="#local.globals.site_domain#/?zreset=site">Click here</a> to force it to update.');
		}else{
			application.zcore.status.setStatus(request.zsid, 'Site import complete, but app cache hasn''t updated yet.  <a href="#local.globals.site_domain#/?zreset=site">Click here</a> to force it to update.');
			application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
		}
	}
	
	
	if(debug){
		writeoutput('done');
	}else{
		application.zcore.status.setStatus(request.zsid, "Site import complete");
		application.zcore.functions.zRedirect("/z/server-manager/admin/site-import/index?zsid=#request.zsid#");
	}
	 </cfscript>
</cffunction>
</cfoutput>
	<!--- 
site-backup.cfm notes:
	// all existing table relationships in the exact order they should be exported.
	a1=arraynew(1);
	arrayappend(a1, {source="database.table.table_id", destination:"database2.table2.table_id"});
	/backup-database-test.cfm
	
	import new id for all rows so that all primary keys are available.   then go back and update the foreign keys within the table.
	all the tables with multi-field primary key must be inserted after the others are done.
	
	must retain compatibility with old export versions.   If it was stored as insert statement, it would be harder to modify.  I need to be using array objects that can be filtered later by a script that will upgrade them to the new version.
		i.e.
		fs["database.table"]=["field1","field2","etc"];
		// put all table structures in a single the export file name table-index.tsv
		#table-export-id	datasource-variable-name	table-name	field-name	field-name2	etc
		1	"zcoreDatasource"	"table"	"field1"	"field2"	"etc"
		
		// put each table in a separate table-name.tsv
		"data1"	"data2"	"etc"
		
		
	TODO: more thorough db structure verification and ALTER SQL generation
		
	show databases
	
	SHOW TABLES IN `zcore`
	
	SHOW TABLE STATUS FROM `zcore` WHERE ENGINE IS NOT NULL; 
	SELECT CCSA.character_set_name FROM information_schema.`TABLES` T, information_schema.`COLLATION_CHARACTER_SET_APPLICABILITY` CCSA WHERE CCSA.collation_name = T.table_collation  AND T.table_schema = "zcore"  AND T.table_name = "site";
	#table struct
	tableStruct=structnew();
	tableStruct["zcoreDatasource"]=structnew();
	tableStruct["zcoreDatasource"]["tablename"]={engine="",version="",create_options="",collation="",charset=""};
	
	
	show FIELDS from #request.zos.queryObject.table("site", request.zos.zcoreDatasource)# 
	#table field struct:
	fieldStruct["zcoreDatasource.name"]=structnew();
	fieldStruct["zcoreDatasource.name"]["fieldname"]={type="",null="",key="", default="",extra=""};
	
	show KEYS from #request.zos.queryObject.table("site", request.zos.zcoreDatasource)# site
	#keys struct
	keyStruct["zcoreDatasource.name"]=structnew();
	keyStruct["zcoreDatasource.name"]["keyname"]={non_unique="",key_name="",seq_in_index="",column_name="",index_type=""};
	
	non_unique=1 is NOT UNIQUE
	non_unique=0 is UNIQUE
	
	uniqueStruct=structnew();
	// tableStruct2 is the NEW structure
	for(i in tableStruct){
		for(n in tableStruct[i]){
			if(structkeyexists(tableStruct2, n) and structkeyexists(tableStruct2, i)){
				uniqueStruct[n&"."&i]=true;
				if(tableStruct[i][n].engine NEQ tableStruct2[i][n].engine){
					// add alter engine sql
				}
				if(tableStruct[i][n].version NEQ tableStruct2[i][n].version){
					// not sure about this one
				}
				if(tableStruct[i][n].create_options NEQ tableStruct2[i][n].create_options){
					// can this be altered?
				}
				if(tableStruct[i][n].collation NEQ tableStruct2[i][n].collation){
					// add alter collation sql
					// CONVERT TO CHARACTER SET `#tableStruct2[i][n].charset#` COLLATE `#tableStruct2[i][n].collation#
				}
			}
		}
	}
	for(i in tableStruct2){
		for(n in tableStruct2[i]){
			if(structkeyexists(uniqueStruct, n&"."&i) EQ false){
				// must create table from scratch
				tableStruct2[i][n];
			}
		}
	}
	
	SHOW CREATE TABLE #request.zos.queryObject.table("site", request.zos.zcoreDatasource)# site;
 --->
 </cfcomponent>